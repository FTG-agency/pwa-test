# Классификкация языков программирования  
- по конструкциям для выделения блоков кода
- по размеру «вокабуляра»(golang - 25, c# - 100)
- по сфере применения
- по тьюринг полноте
- GPL/DSL
- по уровню абстракции (внутри категории «высокоуровневые» есть много оттенков «высокоуровневости»)
- по управлению паматью (автоматическое/ручное)
- трансляторы - компиляторы и интерпретаторы (компилируемые и интерпретируемые) (один язык может иметь и компилятор и интерпретатор)
- скриптовые / не скриптовые
- по типизации
- по производительности (на самом деле этот признак следует из набора признаков выше)
- по парадигме программирования (еще бывают мультипарадигменные)
![[IMG_9965.png]]

![[IMG_9967.png]]

![[IMG_9966.png]]

![[IMG_9968.png]]
---

## 1. Синтаксис оформления блоков кода  

| Подход | Краткое описание | Примеры языков |
|--------|------------------|----------------|
| **Фигурные скобки `{ … }`** | Блок кода ограничивается парой фигурных скобок. | C, C++, Java, C#, Rust, JavaScript |
| **Ключевые слова `begin … end`** | Начало/конец блока задаются специальными словами. | Pascal, Delphi, Ada |
| **Отступы** | Структура определяется горизонтальными отступами (whitespace‑sensitive). | Python, Haskell (layout‑rule) |
| **Префиксная нотация + скобки** | Почти всё — выражения в круглых скобках; позиция оператора перед операндами. | Lisp‑семейство, Clojure, Scheme |

---

## 2. Многословность (объём ключевых слов)  

| Категория | Примерный объём зарезервированных слов | Примеры |
|-----------|----------------------------------------|---------|
| **Компактные** | ≤ 30 | Go (25 keywords), Lua, Kotlin‑сcripting |
| **“Словарные”** | ≥ 80 | C# (~100), C++ (≈ 100 в C++23), Swift |

> Чем больше зарезервированных слов, тем богаче встроенный синтаксис, но тем сложнее учить и парсить язык.

---

## 3. Область применения  

>**Тьюринг-полнота** — это свойство вычислительной системы (или языка программирования), означающее, что на ней можно реализовать **любой алгоритм**, который вообще можно описать формально.
>Иными словами:  
>если язык Тьюринг-полный, на нём теоретически можно написать любую программу — от калькулятора до операционной системы.
### 3.1. GPL — *General‑Purpose Languages*  
Языки общего назначения; обязательно тьюринг‑полные.  
**Примеры:** Python, Java, C++, Rust, Swift, Kotlin, JavaScript (сегодня).

### 3.2. DSL — *Domain‑Specific Languages*  
Ориентированы на узкую предметную область; тьюринг‑полнота — опциональна.  

| Область                | Примеры DSL-языков  |
| ---------------------- | ------------------- |
| Запросы к базам данных | SQL                 |
| Описание аппаратуры    | Verilog, VHDL       |
| Научные вычисления     | MATLAB, R           |
| Разметка и стили       | HTML, CSS *(не ТП)* |

Некоторые DSL со временем эволюционируют в GPL (классический пример — JavaScript).

---

## 4. Уровень абстракции  

| Категория | Характеристика | Примеры |
|-----------|----------------|---------|
| **Низкоуровневые** | Требуют учитывать архитектуру процессора; почти 1:1 с машинным кодом. | Машинный код, Assembler |
| **Средний уровень** | Даёт доступ к “железу”, но уже скрывает часть деталей. | C |
| **Высокоуровневые** | Абстрагируются от платформы и упора на скорость разработки. | Python, Java, JavaScript, Swift |

---

## 5. Управление памятью  

| Подход | Кто отвечает | Примеры |
|--------|--------------|---------|
| **Ручное (manual)** | Программист явно `malloc/free`, `new/delete`. | C, C++, Pascal, Rust (ownership) |
| **Автоматическое (GC)** | Сборщик мусора освобождает неиспользуемые объекты. | Java, Go, C#, JavaScript, Python |

---

## 6. Способ трансляции  

| Вид | Что происходит | Примеры языков / реализаций |
|-----|----------------|-----------------------------|
| **Компилируемые** | Исходник → бинарный файл один раз, далее запускается без компилятора. | C, C++, Rust, Go, Swift; Java (byte‑code JIT) |
| **Интерпретируемые** | Исходник читается и выполняется строка‑за‑строкой интерпретатором. | Python (CPython), Ruby, Bash, PHP (CLI) |

> Реальный язык может иметь и компилятор, и интерпретатор (пример: JavaScript — JIT‑компиляция в движке V8).

---

## 7. Типизация  

| Категория | Когда известен тип | Примеры |
|-----------|--------------------|---------|
| **Статическая** | На этапе компиляции; измениться не может. | C++, Java, Go, TypeScript |
| **Динамическая** | Определяется во время выполнения; можно менять. | Python, JavaScript, Ruby, PHP |

Доп. оси: *сильная ↔ слабая*, *вывод типов* (type inference).

---

## 8. Производительность  

***Для максимальной скорости*** → компилируемый, статически типизированный язык с ручным управлением памятью.  
**Короли перформанса:** C, C++, Rust, Zig.  

***Для скорости разработки*** → динамические/высокоуровневые (Python, JS, Ruby). Часто «хватает» производительности + удобства.

---

## 9. Парадигмы программирования  

| Парадигма | Кратко | Примеры «чистых» | Большинство современных — мультипарадигмные |
|-----------|--------|------------------|---------------------------------------------|
| **Императивная** | Код = последовательность команд; изменяемое состояние. | C, Pascal | C++, Java, Python |
| **Функциональная** | Вычисления как применение функций, без побочных эффектов. | Haskell, Elm | Scala, JavaScript (частично) |
| **ООП** | Сущности = объекты + классы; инкапсуляция/наследование/полиморфизм. | Smalltalk, Java (классический) | C++, Python, Swift |

---

## 10. Другие оси классификации  (кратко)

* **Конкурентная модель**: акторы (Erlang), CSP (Go), async/await (JS ES2017).  
* **Сильная vs слабая типизация**, **вывод типов** (Haskell, Rust).  
* **Система модулей/пакетов**, **метапрограммирование** (C++ templates, Rust macros).  
* **Время появления**: «зрелые» (Fortran 1957) vs «современные» (Zig 2016).  

---

## Итог  

Классификация помогает понять **плюсы, минусы и область применения** каждого языка.  
Чаще всего один язык попадает сразу в несколько «коробочек» — например, *Rust* одновременно:  

* Высокоуровневый (но «близко к металлу»),  
* Компилируемый,  
* Статически и строго типизированный,  
* С ручным управлением памятью (через ownership),  
* Мультипарадигменный (императив + функциональные элементы).  

Выбирайте язык под **конкретную задачу**, оценивая его по этим критериям.
